//
//  testmplbbreak.c
//  Morphy
//
//  Created by Martin Brazeau on 15/01/2019.
//  Copyright Â© 2019 Martin Brazeau. All rights reserved.
//
#include "mpltest.h"
#include "testutils.h"

#include "testmplbbreak.h"
#include "../src/Trees/mpl_node.h"
#include "../src/Trees/mpl_tree.h"
#include "../src/Trees/mpl_topol.h"
#include "../src/Trees/mpl_newick_rdr.h"
#include "../src/Characters/mpl_matrix.h"
#include "../src/Analysis/mpl_scoretree.h"

int test_bbreak_reroot_all_for_subtree (void)
{
    theader("Test rerooting of a subtree");
    
    int failn = 0;
    
    // Set up a tree
    long numtaxa = 10;
    char* nwkstring = "((((1,((2,7),(5,9))),(4,8)),6),(3,10));";
    
    mpl_newick_rdr nwkrdr;
    mpl_topol top;
    top.num_taxa = 1;
    top.edges = NULL;
    mpl_topol_reset(numtaxa, &top);
    
    mpl_newick_rdr_init(numtaxa, &nwkrdr);
    mpl_newick_read(nwkstring, &top, &nwkrdr);
    
    mpl_tree* t = mpl_new_tree(numtaxa);
    
    mpl_tree_read_topol(t, &top);
    
    char* nwkout = NULL;
    mpl_tree_write_newick(&nwkout, t);
    printf("Original tree:\t\t\t%s\n", nwkout);
    free(nwkout);
    
    // Clip a 'non-trivial' branch
    mpl_node* src = NULL;
    mpl_node* clipsite = NULL;
    
    mpl_node* toleft = NULL;
    mpl_node* toright = NULL;
    //   Using ancestor of the ancestor of tip 2 which shoudl be the subtree
    //   ((2,7),(5,9))
    src = t->nodes[1].anc->anc;
    clipsite = mpl_node_get_sib(src);
    
    if (src->anc->left == clipsite) {
        toleft = clipsite;
    }
    else {
        toright = clipsite;
    }
    
    mpl_node* sites[10];
    mpl_node** s, **sn;
    
    s = sites;
    sites[0] = src->left;
    sites[1] = src->right->left;
    sites[2] = src->right->right;
    sn = &sites[3];
    
    for (s = sites; s < sn; ++s) {
        
        // Clip the node
        mpl_node_bin_clip(src);
        
        // Perform a rerooting
        mpl_test_bbreak_tbr_reroot(*s, src);
        
        if (!(*s)->tip) {
            *sn = (*s)->left;
            ++sn;
            *sn = (*s)->right;
            ++sn;
        }
        
        // Reconnect and print the tree
        mpl_node_bin_connect(toleft, toright, src);
        
        mpl_tree_write_newick(&nwkout, t);
        printf("With rerooted subtree:\t%s\n", nwkout);
        free(nwkout);
        nwkout = NULL;
        
        if (mpl_tree_checker(t)) {
            ++failn;
            pfail;
        }
        else {
            ppass;
        }
    }

    return failn;
}

int test_bbreak_store_allswaps (void)
{
    theader("Test making a list of all SPR rearrangements");
    
    int failn = 0;
    
    // Set up a tree
    long numtaxa = 10;
    char* nwkstring = "((((1,((2,7),(5,9))),(4,8)),6),(3,10));";
    
    mpl_newick_rdr nwkrdr;
    mpl_topol top;
    top.num_taxa = 1;
    top.edges = NULL;
    mpl_topol_reset(numtaxa, &top);
    
    mpl_newick_rdr_init(numtaxa, &nwkrdr);
    mpl_newick_read(nwkstring, &top, &nwkrdr);
    
    mpl_tree* t = mpl_new_tree(numtaxa);
    mpl_tree_read_topol(t, &top);
    mpl_tree_rebase(0, t);
    
    char* nwkout = NULL;
    mpl_tree_write_newick(&nwkout, t);
    printf("Original tree:\t\t\t%s\n", nwkout);
    free(nwkout);
    
    // Declare and initialise a bbreak struct
    // For now: manually set parameters in the search and bbreak structs
    mpl_search s;
    s.treelist = mpl_treelist_new(10, 1000, 0);
    
    s.bbreak_type = MPL_SPR_T;
    
    mpl_bbreak bbk;
    // The number of nodes in the bbreak will be the size of the tree
    mpl_tree_traverse(t);
    bbk.num_nodes = t->size;
    // Now the bbkreak struct can be initialised
    mpl_bbreak_init(&s, &bbk);
    
    mpl_test_branch_swap(t, &bbk);
    
    int i = 0;
    for (i = 0; i < bbk.treelist->num_trees; ++i) {
        mpl_tree_read_topol(t, &bbk.treelist->trees[i]);
        mpl_tree_write_newick(&nwkout, t);
        printf("TREE Morphy_%i\t=\t[&U] %s\n", (i + 1), nwkout);
        free(nwkout);
    }
    
    return failn;
}


int test_bbreak_store_TBR_allswaps (void)
{
    theader("Test making a list of all SPR rearrangements");
    
    int failn = 0;
    
    // Set up a tree
    long numtaxa = 24;
    char* nwkstring = "(1,(((((2,3),6),(12,((7,(8,9)),(10,11)))),4),((19,((20,21),(((13,5),(14,15)),(16,(17,18))))),(22,(23,24)))));";
    
    mpl_newick_rdr nwkrdr;
    mpl_topol top;
    top.num_taxa = 1;
    top.edges = NULL;
    mpl_topol_reset(numtaxa, &top);
    
    mpl_newick_rdr_init(numtaxa, &nwkrdr);
    mpl_newick_read(nwkstring, &top, &nwkrdr);
    
    mpl_tree* t = mpl_new_tree(numtaxa);
    mpl_tree_read_topol(t, &top);
    mpl_tree_rebase(0, t);
    
    char* nwkout = NULL;
    mpl_tree_write_newick(&nwkout, t);
    printf("Original tree: %s\n", nwkout);
    free(nwkout);
    
    // Declare and initialise a bbreak struct
    // For now: manually set parameters in the search and bbreak structs
    mpl_search s;
    s.treelist = mpl_treelist_new(numtaxa, 20000, 0);
    
    s.bbreak_type = MPL_TBR_T;
    
    mpl_bbreak bbk;
    // The number of nodes in the bbreak will be the size of the tree
    mpl_tree_traverse(t);
    bbk.num_nodes = t->size;
    // Now the bbkreak struct can be initialised
    mpl_bbreak_init(&s, &bbk);
    
    mpl_test_branch_swap(t, &bbk);
    
    int i = 0;
//    for (i = 0; i < bbk.treelist->num_trees; ++i) {
//        mpl_tree_read_topol(t, &bbk.treelist->trees[i]);
//        mpl_tree_write_newick(&nwkout, t);
//        printf("TREE Morphy_%i\t=\t[&U] %s\n", (i + 1), nwkout);
//        free(nwkout);
//    }
    
    printf("\nTBR complete. %li rearrangements tried\n", bbk.num_rearrangs);
    
    return failn;
}


int test_single_rep_hsearch (void)
{
    theader("Test single-replicate heuristic search");
    
    int failn = 0;
    
//    int ntax = 28;
//    int nchar = 95;
    int ntax = 47;
    int nchar = 134;
    int hold = 5; // Hold up to 3 trees
    
    char* rawmatrix =
//    "0000000000 0000000000 000---0000 000-000000 0000000000 000-0-0000 0000000000 00000--000 0000000000 0000?\
//    11-1012100 1120200001 001---0000 100-1--100 0100000110 1010320010 0000101000 01000--303 0000000000 0010?\
//    ?????????? ?????????? ??30--0010 ??0-?????? ??1-?-??10 0?0-??1?-- ????0?00?? 10??1112?? ????100111 -0-1?\
//    00??0????? ?????????? ??3111100? ?????????? ??011100?? 0???????11 ?1???????? 10?????2?? ????1?1-1? ?????\
//    000?0????? ??11??0111 1030--???1 010-???0?? ??1---0-10 010-3?00-- ??010?000? ?0??111?1- ?0?111011? ???1?\
//    11-1012010 11212?0001 002---0001 100-010100 1100000110 1010320010 0000101010 01000--103 1000000000 0000?\
//    00?100(02)??? 01?1(23)0???1 0?0---00?0 0010002?00 1100000001 000-31-010 ????-?30?0 00000--01- 0???00?000 0100?\
//    1011023111 112131???1 100---0000 00101--200 0100001010 00103011?0 1-1-010011 01010?-11- 10??00?0?0 0010?\
//    ?????????? ???????0?? ??3000?10? 010-0100?0 1100-0--10 0011300?10 ????0????0 010110021- 1???100110 1000?\
//    1011023110 1111311001 110---0000 000-1---00 0100001010 000-301110 1-1-013110 01010--11- 0010000000 00100\
//    ?????????? ??????0??? ??3000?1?0 ??0-010?1? 1100100?10 0?11??0?00 ????0??0?0 00111002?? ????100110 10001\
//    ?????????? ??????0001 ??3101?100 ????0????? ?100110010 0011??0?01 0100?????? 00??1002?? ??1?10???? ??001\
//    ?????????? ??2????11? ????--???? ?????????? ??1-?-??1? ????????-- ?????0?00? 10?????2?? ???110011? ???10\
//    11-11?301? 1111(23)?0010 002---0000 0011012101 1100000111 001011-010 ?0001?0110 00000--?02 1?00000000 01001\
//    11-11?3001 2120000000 001---0000 0011002101 1100000101 000-11-000 0000100100 01000--101 110?000000 00000\
//    0011012?10 11?12??011 002---0000 1010002?00 1100000?10 1010??1??0 ??001?10?0 0100??-??? 1??0?????? ?0000\
//    1001??30?? 112???0010 01?---0000 000-1--201 1100000111 000-2?-010 0000102110 01000--002 1?00000000 00000\
//    ?????????? ???????11? ??30--0010 010-?????? ?11-?-??10 010-3010-- 0001?00000 10?????2?? ????10011? ?0-10\
//    0???0?1??1 ?0?1??00?? ??311111?? 010-0100?0 1100110010 0011??0?01 ??????0??0 0011???21- 101?1001(01)0 10001\
//    00000?1011 1011300001 1030000100 010-010010 1100100010 001?300010 0000000001 0{01}1110021- 101110?101 -0001\
//    0010000010 1011101000 110---0-00 0010011000 0100001010 0010301110 0?0?00?0?1 01010--11- 0?1?000000 00000\
//    00000?1?1? ?0113?0001 1031111101 010-01?0?0 ??01110010 0?0-300001 0100?0?0?? 10?110(01)21- ?011111-10 10?11\
//    ?00?????1? 1?213?01?1 ????--0011 ?????????? ??1-?-??10 010-??0?-- ??0??0000? ?0???????? ?????????? ????0\
//    11-11?3??? 1?2???0000 00?---0000 0011011101 1100000111 001011-010 0000100110 00000--002 11??000000 01000\
//    00?00000?0 1021100000 002---0000 10111--100 1000000110 1010320010 00001000?0 01000--100 10??00?000 00000\
//    ?????????? ?????????? ??30--???? ?????????? ??1-?????0 ?????????? ??0????0?? ?????????? ?????????? ????0\
//    ?????????? ???????1?1 ??3000?0?1 ????010??? ?1001???10 0011??0??0 00??0??0?0 00??11021- 1??1100111 -0001\
//    ?????????? ?????????? ?????????? ?????????? ?100?????? ???????0?0 00??????0? 00?????21- ???1100111 ---1?;";
    
    "0000-0-???01001?1?000??--00-000------0-0-----?---------000?100?0-0000000-00?0-----010-000--00-0000--------?--0----0-0??---??0-?----0??\
    000100010??0110?0?10000--00-000----0-0-0-----?---------000000000-0000000-00?0-----010-000--00-?0100000-0?1?--0-1001?00-000?0?-00---00?\
    000120011001001100111??-0?10001121?0-0-?0-----001110010?011?1??01?0111??0111101?011110?011-11011111---0-1{12}0101001110100001111100100011\
    10012000?000?0-10?1?1??-0?0-000----0-0-?11110-0011000001001?10?000111010110?111?111?101111-01010001---0-11-001011110111001100100000000\
    0100-00?--?--0?00?0-0000100-0-0----100-0?----?0100-0??0?0?0?0??????0?????0??????????????0?????????000010?0???1--001-0--110000-00---010\
    000??0???????11???100??-0?1011100000-0-??-?---00??????????1?1?????????????????????????????-???????01-10-1201010??01?10?00?111011110001\
    0001?0??00010???0?0-?000?10-1-?????10??????????????????0?001000000000000-0000100?0100-000-100-00?000????11-00101?01?????01??1??0??????\
    0101000100?1101100100??-0?11000----0-0-011100-00??????????1?1?????????????????????????????-???????1---0-?2????-??-1?10000?111111111001\
    00?1?0?10001????0?0-0011110-0-0----110-010--0?0100-0??001010100001010010-0000000?01???0012100-0010000011?10?-1?1??1?????0?0?1??000????\
    000??001?010100?1?0-11-0010-1-?----110-112---?0100-0??0?0????????????0????0??????0??????0-1???????000110?1??-1-??01?1110011010000-01?0\
    0?0??0???0010?1???10???-?110??111?10-0-?0-----?0??????????1?1?????????????????????????????-???????1---0-121???????1?10?00?111010100001\
    00012001100100110?111??-0?1000111110-0-?0-----001110000?0?1?1???????????????????01????????-???????1---0-1211010??11?10000?111100100011\
    0001201101010110110-01-110101-1100110111110-001111-?11??101?10?????11????1????0?0??????????1??????00110-?0???1????1010000?000-00---011\
    110?????????????0??????-????????????????1111???0110?0001?110???000011010100011111110111111?0110000????????????????????????????????????\
    11012001000??021??111??-0?11000----0-0-?11110-001100000?0?1?10?000111????1???11?11??1??111-01??0101---0-11-00101101?10000?100000?00000\
    0001000??00010110?10000-0?1011100000-0-011100-0011??000?0???1?????????????????????????????-???????01-10-1200010??01?10?00?111011110001\
    000??00??????0??0?0-0011110?0-0----110-0110-0101????????1?1?1????????????0????????????0???????????000011?10?-1????1?10?00?001-0001-111\
    ??0??001?00100110?100??-1?10000----0-0-0???---0?????????????1?????????????????????????????-???????01-10-120?010??01?1?000?111100100001\
    010??0??0110111???0-01-101??1????????100110-001???????????1?1?????????????????????????????????????00110-??????????1?10000??00-00---?01\
    00?110?1?0??????0?0-0011110-0-0----100-010--0-0100-0???01010100001010010-0001000?0100-0012100-00?0000010010?-1-1101????0010?1-?001-1??\
    01?1?0011001001??0110??-0?12100----??0-?0---0-01????????????1?????????????????????????????-???????00110-11101000?01?100001111110100001\
    1?0??0010???????0?10???-0?????0----0-0-?11110-001?????0101??10?0001010???0??111?11?011?111-01000?0???-????????????1????00???1???11????\
    00010001?0011011?0100??-0?1000111110-0-?11100-00????????0???1?????????????????????????????-???????0-110-1211010???1?10000?111011100001\
    0001200110010011??100??0011210100010-0-?0-----00??????1?????1?????????????????????????????-???????1---0-11001001?01?10000?111111110?01\
    1101200??00010210?110??-0??-000----0-0-?11100-00?1??0?01011?11?00?0110??-???0???1??011?011-00??0?01---0-11-001011010101000100100101001\
    000??00??001001100111??-0?10001121?0-0-?0-----001110010?011?1?????011????11?????01??????11-1?????11---0-1211010??11?10000?111100100011\
    ?????01?01101110110-01-110101-11001101111110101111-?1???1?1?10?010?111???11?????0??????010011????100110-?1-??1??101110000?000-00---?11\
    000??0???0010011?0100??-0?1?00110110-0-?1110110111?1000?0???1???????????????????????????1?-???????1---0-1211011??11?10000?111100100001\
    010??001????1??????????-??????0??-?0-????????-??1?????????????????????????????????????????-???????1---0-?0????-???1?10?00?11111110?001\
    001??0????????????0-?1-1???????????????1???????????????0?01010101?01101?01??1?000?1?100011?11?????????????????????????????????????????\
    00?110??????????1?0-?000?10-1-??????0??1???????????????00?1100?000000000-000?1-1?0100-000-100-?00000??????????????1?????????1???01????\
    000??00???0?0?11??101??-0110?0111110-0-?0-----0011????0?0?1?1???????????????????0?????????-???????1---0-111101?0??1?10000?111010100011\
    0011201101101110110-01-110101-1100110111110-001111-1100010111010100111110111111?00111000100110111100110-01---1-01011100001000-00---011\
    0101200000?01021??110??-0?0-00?0?????0-?1?----00????????????1?????????????????????????????????????1---0-?0????-??-1?10?00?111101110001\
    0011201100100?10?00-01-111101-1100?10101111010111101????101110111001001-?1111???011????01?011??1??00110-01---1-0001-100001000-00---001\
    1001200??????0????1????-0?????0----0-0-?11110-00110100010010?1?000011010100011111110111111-01100001---0-11-00101?11?10100?100?00??10-1\
    0?0??00100???01???100??-0?1011100000-0-011100-00????????0???1?????????????????????????????-???????01-10-1201010??01?10000?111111111001\
    000120?100010?1???10???-0??????????0????11101101?1???00???????????????????????????????????-???????1---0-1211011???1?10?00?111?00100001\
    0011211101101010000-01-110101-110?1101011110101111010000101110?110011011?111101?0111???010011??10100110-01---1-0001-100001000-00---?01\
    0101?0011011001???101??-011000111010-0-00-----00110???0???1?1????????????????????1????????-???????1---0-12110000?11?10?00?111011100011\
    001??1?????0??????0-01-?10???-?????????1111?101???????00101?10?110010011?1??1???0?11100010?11?????00?????11??1???01?????0?1?10?0100???\
    010??001?0???100??0-00??100?0-0?---100-00---??0?????????0?0?0??????0????????????????????0?????????0?0010?0???1--00?-0--11??00?00---010\
    ?00??00??00110110?100??-0110001?000?????11100-0011?0000?0?1?10??0???0????0???0000???????????????10011-0-11000101?01?10000?111011110001\
    110?????????????0??????-??????????????????????????0??????11????00001101?110?11010110101111?11?0?10??????1?????????????????????????????\
    010??0???????00?1?0-11-0010-1-0----110-112---?010?-?????0????????????????????????0??????0-1???????00011???0?-1-???1?11100?101000110?00\
    110??0?1-0001???0?11???-????????????????1111?0?0110??001?11??1?000011010100011111110111111-0100000????????????????????????1??1??11????\
    0001200110010011??110??-0?12000----0-0-0110-0?0101-0001???1?1????????????????????0????????-???????1---0-11000100?11?10000?111000110001;";
    

    
    mpl_matrix* m = mpl_matrix_new();
    mpl_matrix_set_nrows(ntax, m);
    mpl_matrix_set_ncols(nchar, m);
    mpl_matrix_set_nnodes(2 * ntax, m);
    mpl_matrix_attach_rawdata(rawmatrix, m);
//    mpl_matrix_set_gap_handle(GAP_MISSING, m);
    mpl_matrix_apply_data(m);
    mpl_init_parsimony(m);
    
    mpl_search s;
    s.treelist = mpl_treelist_new(ntax, 20000, 0);
    s.num_taxa = ntax;
    s.bbreak_type = MPL_TBR_T;
    
    mpl_bbreak bbk;
    // The number of nodes in the bbreak will be the size of the tree
    bbk.num_nodes = 2 * ntax-1;
    // Now the bbkreak struct can be initialised
    mpl_bbreak_init(&s, &bbk);
    bbk.bbktype = MPL_TBR_T;
    mpl_do_bbreak(&bbk);
    
    mpl_tree* t  = mpl_new_tree(ntax);
    mpl_topol* top = NULL;
    char* nwkresult = NULL;
    int i = 0;
    
    for (i = 0; i < bbk.treelist->num_trees; ++i) {
        top =  mpl_treelist_get_topol(i, bbk.treelist);
        mpl_tree_read_topol(t, top);
        
        mpl_tree_write_newick(&nwkresult, t);
        printf("TREE Morphy_%i = [&U] %s [length: %.0f]\n", i+1, nwkresult, top->score);
        free(nwkresult);
    }
    
    return failn;
}
